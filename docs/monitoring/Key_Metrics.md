# Key Metrics

**Purpose:** Define and explain the most important metrics generated by the application services and how they can be used for monitoring health and performance.
**Prerequisites:** Understanding of OpenTelemetry Metrics concepts (Counter, Histogram). See [Glossary](../Glossary.md).
**Related Pages:** [Telemetry Setup](./Telemetry_Setup.md), [Monitoring Overview](./README.md), `common/telemetry/metric/metric.go`

---

## 1. Overview & Key Concepts

The application emits custom metrics using the OpenTelemetry Go SDK to provide insights into operation counts, durations, and errors.

*   **Key Concept: Metric Instruments:** Specific types of instruments (Counter, Histogram) are used to record different kinds of measurements.
*   **Key Concept: Attributes/Dimensions:** Metrics are recorded with key-value attributes (dimensions) that allow filtering and grouping during analysis (e.g., show duration by operation name).
*   **Core Responsibility:** Quantify application performance and behavior.
*   **Why it Matters:** Metrics are essential for building dashboards, setting alerts, and understanding performance trends over time.

---

## 2. Configuration & Setup

Metrics are defined in `common/telemetry/metric/metric.go` using a named `Meter` (`common/telemetry/metric`). The OTLP export pipeline is configured in [Telemetry Setup](./Telemetry_Setup.md).

**Relevant Files:**
*   `common/telemetry/metric/metric.go`: Defines metric instruments (`app.operations.*`) and the `MetricsController` helper.
*   `common/telemetry/metric/exporter.go`: Configures the OTLP exporter and global `MeterProvider`.
*   `product-service/src/repository.go`: Example usage of the `MetricsController` pattern.

**Initialization:**
*   Metric instruments (`operationsTotal`, `durationMillis`, `errorsTotal`) are created in the `common/telemetry/metric/metric.go` package `init()` function.
*   The global `MeterProvider` configured in [Telemetry Setup](./Telemetry_Setup.md) makes these metrics available for recording.

---

## 3. Defined Custom Metrics (`app.*`)

The following custom metrics are defined in `common/telemetry/metric/metric.go` and `common/telemetry/metric/custom_metrics.go`:

1.  **`app.operation.requests.total`** (Formerly `app.operations.total`)
    *   **Type:** Counter (Int64)
    *   **Unit:** `{operation}`
    *   **Description:** Total number of operations executed (e.g., API endpoint calls, database interactions).
    *   **Key Attributes:** `app.error`, plus any additional attributes passed via `MetricsController.End`.

2.  **`app.operation.duration.milliseconds`** (Formerly `app.operations.duration_milliseconds`)
    *   **Type:** Histogram (Float64)
    *   **Unit:** `ms`
    *   **Description:** Duration of operations in milliseconds.
    *   **Key Attributes:** `app.error`, plus any additional attributes passed via `MetricsController.End`.

3.  **`app.operation.errors.total`** (Formerly `app.operations.errors.total`)
    *   **Type:** Counter (Int64)
    *   **Unit:** `{error}`
    *   **Description:** Total number of operations that resulted in an error.
    *   **Key Attributes:** `app.error` (always true for this metric), plus any additional attributes passed via `MetricsController.End`.

4.  **`app.product.creations.total`**
    *   **Type:** Counter (Int64)
    *   **Unit:** `{product}`
    *   **Description:** Total number of new products successfully created.
    *   **Key Attributes:** None currently defined.

5.  **`app.product.updates.total`**
    *   **Type:** Counter (Int64)
    *   **Unit:** `{product}`
    *   **Description:** Total number of products successfully updated.
    *   **Key Attributes:** None currently defined.

6.  **`app.product.inventory.count`**
    *   **Type:** Observable Gauge (Int64)
    *   **Unit:** `{item}`
    *   **Description:** Current inventory stock level for each product.
    *   **Key Attributes:** `product.id`
    *   **Note:** This metric relies on a callback mechanism. The function `common/telemetry/metric.UpdateProductStockLevels()` must be called periodically with the latest stock counts (map[string]int64) for this gauge to report accurate data.

(Note: Metric definitions are centralized in `common/telemetry/metric/custom_metrics.go` and instantiated in `metric.go`. The `MetricsController` pattern simplifies recording the operation request, duration, and error metrics together.)

---

## 4. Implementation Details & Usage

The `MetricsController` helper pattern (`common/telemetry/metric/metric.go`) is used to simplify recording the three core operation metrics together (requests, duration, errors).

**`MetricsController` Pattern:**
*   Call `metric.StartMetricsTimer()` at the beginning of an operation.
*   Use `defer timer.End(ctx, &err, ...)` to ensure metrics are recorded when the operation finishes.
*   The `End` method records `app.operation.requests.total`, `app.operation.duration.milliseconds`, and `app.operation.errors.total`, attaching `app.error` and any extra attributes passed.

**Product-Specific Counters:**
*   After a successful product creation, call `timer.IncrementProductCreated(ctx)`.
*   After a successful product update, call `timer.IncrementProductUpdated(ctx)`.

**Inventory Gauge:**
*   The `app.product.inventory.count` gauge is updated via a callback registered with the OpenTelemetry SDK.
*   To provide data to this callback, your application logic **must** periodically call `common/telemetry/metric.UpdateProductStockLevels(stockMap)` with a map where keys are product IDs and values are their current stock counts.
    *   A good place to call this might be after retrieving all products, or on a regular timer if stock levels are volatile.

**Example Usage (Conceptual - combining patterns):**
```go
func (s *productService) UpdateProduct(ctx context.Context, id string, /*...update data...*/) (opErr error) {
    productIdAttr := attribute.String("product.id", id) // Example attribute
    // Start timer for the service operation
    mc := commonmetric.StartMetricsTimer()
    // Ensure End is called, passing error pointer and additional attributes
    defer mc.End(ctx, &opErr, productIdAttr)

    // ... service logic that might set opErr ...

    // If update was successful:
    if opErr == nil {
        mc.IncrementProductUpdated(ctx) // Increment update counter
    }

    // Periodically (e.g., in a background task or after certain bulk ops):
    // latestStock := s.repository.GetCurrentStockLevels(ctx) // Fetch current levels
    // commonmetric.UpdateProductStockLevels(latestStock) // Update gauge data source

    return opErr
}
```

---

## 5. Monitoring & Observability Integration

*   These `app.*` metrics are exported via the OTLP pipeline configured in [Telemetry Setup](./Telemetry_Setup.md).
*   They will appear in SigNoz and can be used to build dashboards and alerts.
*   The common attributes allow filtering/grouping (e.g., view average duration using `app.operation.duration.milliseconds`, or filter inventory by `product.id`).

---

## 6. Visuals & Diagrams

<!-- 
[USER ACTION REQUIRED]
Insert actual screenshot(s) from SigNoz showing time-series charts for repository metrics.
Example: A dashboard panel showing app.operations.total, app.operations.duration_milliseconds (P95), and app.operations.errors.total for the repository layer, potentially grouped by app.operation.

Example Markdown:
![Repository Metrics Dashboard Panel](../assets/images/repo_metrics_dashboard.png)
*Fig 1: Example Repository Metrics Charts from SigNoz.*
-->

*Placeholder for Repository Metrics Charts.*

---

## 7. Teaching Points & Demo Walkthrough

*   **Key Takeaway:** Custom metrics provide application-specific insights. Helpers like `MetricsController` can standardize related metrics. Observable gauges require a mechanism (like `UpdateProductStockLevels`) to provide data periodically.
*   **Demo Steps:**
    1.  Show `common/telemetry/metric/custom_metrics.go` and `metric.go`, highlighting the metric definitions, the `MetricsController`, and the `UpdateProductStockLevels` function.
    2.  Show example usage of `StartMetricsTimer`/`End` and the `Increment*` methods.
    3.  Explain where `UpdateProductStockLevels` would be called to feed the inventory gauge.
    4.  Run the application and generate operations (create, update, get products).
    5.  In SigNoz, show dashboards/charts for all `app.*` metrics, including `app.product.inventory.count` (potentially filtered by `product.id`).
    6.  Demonstrate filtering/grouping using available attributes.
*   **Common Pitfalls / Questions:**
    *   Why are operation attributes (`app.layer`, `app.operation`) missing? (The `StartMetricsTimer` function no longer accepts them directly; they need to be passed as additional attributes to `End` if required).
    *   Why is the `app.product.inventory.count` gauge flat or zero? (Check if `UpdateProductStockLevels` is being called correctly and frequently enough with valid data).
*   **Simplification Analogy:** The `MetricsController` is a general operation timekeeper. Specific counters (`product.creations`, `product.updates`) track specific events. The inventory gauge is like a live scoreboard (`app.product.inventory.count`) showing the count for each item (`product.id`), but someone needs to manually update the scoreboard (`UpdateProductStockLevels`) with the latest counts regularly.

---


